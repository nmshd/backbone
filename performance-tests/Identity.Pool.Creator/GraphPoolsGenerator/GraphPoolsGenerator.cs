using System.Collections;
using Backbone.ConsumerApi.Sdk.Authentication;
using Backbone.Identity.Pool.Creator.Application.Checkers;
using Backbone.Identity.Pool.Creator.Application.Printer;
using Backbone.Identity.Pool.Creator.PoolsFile;
using Backbone.Identity.Pool.Creator.PoolsGenerator;
using Backbone.Tooling;

namespace Backbone.Identity.Pool.Creator.GraphPoolsGenerator;

/// <summary>
/// We use a different approach here. Instead of creating all identities, then their relationships and lastly their messages,
/// instead we create a handful of identities first, with no relationships nor messages. This can be considered a graph
/// where relationships are represented by edges, and messages are represented by weighted edges.
/// 
/// After this initial setup, the allocation of messages is done using a mix of relationship creation and pre-existing relationship usage,
/// as per the limits set in the pool configuration.
/// </summary>
public class GraphPoolsGenerator
{
    private readonly string _baseAddress;
    private readonly ClientCredentials _clientCredentials;
    private readonly IPrinter _printer;
    private readonly List<PoolEntry> _pools;

    public GraphPoolsGenerator(
        string baseAddress,
        string clientId,
        string clientSecret,
        PoolFileRoot configuration,
        IPrinter printer)
    {
        _baseAddress = baseAddress;
        _clientCredentials = new ClientCredentials(clientId, clientSecret);
        _printer = printer;
        _pools = configuration.Pools.ToList();
    }

    public async Task CreatePools()
    {
        CreateInitialNodes();

        PoolsOffset.CreateOffsetPools(_pools);

        DeepGenerateV2();

        var (success, messages) = _pools.CheckSolution();
        if (!success)
        {
            Console.WriteLine("Solution validation failed.");

            foreach (var message in messages)
            {
                Console.WriteLine(message);
            }
        }

        _printer.PrintRelationships(_pools, summaryOnly: false);
        _printer.PrintMessages(_pools, summaryOnly: false);
    }
    
    /// TO BE GENERATED BY COPILOT
    /// <summary>
    /// This is the main engine in the program. This method should look into the _pools object and generate relationships for the identities.
    /// It should also exchange messages between identities of each kind of pool. The method should be able to maximize the number of established relationships and
    /// exchanged messages, meeting at least the expected number of sent messages and established relationships.
    /// Due to the possibility to reach local maxima, the method may implement some form of backtracking to explore other solutions.
    /// 
    /// 
    /// </summary>
    private void DeepGenerateV2()
    {
        
    }

    private void DeepGenerateV1()
    {
        Console.WriteLine($"Got called with {_pools.NumberOfEstablishedRelationships()} relationships already established and {_pools.NumberOfSentMessages()} messages sent.");

        var enm = _pools.ExpectedNumberOfSentMessages();
        var enr = _pools.ExpectedNumberOfRelationships();

        Console.WriteLine($"Targets are {enr} relationships and {enm} messages sent.");


        while (true)
        {
            var identities = _pools.SelectMany(p => p.Identities).OrderBy(i => i.GraphAlgorithmVisitCount).ToList();

            uint createdSum = 0;
            foreach (var identity in identities)
            {
                createdSum += SendMessagesRecursive(identity);
            }

            createdSum += AddRelationship();

            if (createdSum == 0)
                break;
        }
    }

    private uint AddRelationship()
    {
        var appIdentitiesWithTheHighestRelationshipCapacity = new Queue<Identity>(
            _pools.GetAppPools()
            .SelectMany(p => p.Identities)
            .Where(i => i.HasAvailabilityForNewRelationships())
            .OrderBy(i => i.Pool.NumberOfRelationships));

        var connectorIdentitiesWithTheHighestRelationshipCapacity = new Queue<Identity>(
            _pools.GetConnectorPools()
            .SelectMany(p => p.Identities)
            .Where(i => i.HasAvailabilityForNewRelationships())
            .OrderBy(i => i.Pool.NumberOfRelationships)
            .ToList());

        while (appIdentitiesWithTheHighestRelationshipCapacity.Any() && connectorIdentitiesWithTheHighestRelationshipCapacity.Any())
        {
            var appIdentityWithTheHighestRelationshipCapacity = appIdentitiesWithTheHighestRelationshipCapacity.Dequeue();
            var connectorIdentityWithTheHighestRelationshipCapacity = connectorIdentitiesWithTheHighestRelationshipCapacity.Dequeue();

            if (appIdentityWithTheHighestRelationshipCapacity.AddIdentityToEstablishRelationshipsWith(connectorIdentityWithTheHighestRelationshipCapacity)) return 1u;
        }

        return 0u;
    }

    private uint SendMessagesRecursive(Identity i, Identity? callingIdentity = null)
    {
        i.GraphAlgorithmVisitCount++;
        uint createdMessages = 0;
        var relatedIdentities = i.IdentitiesToEstablishRelationshipsWith.Except([callingIdentity]) as IEnumerable<Identity>;

        foreach (var relatedIdentity in relatedIdentities)
        {
            if (i.HasAvailabilityToSendNewMessages() && relatedIdentity.HasAvailabilityToReceiveNewMessages())
            {
                i.SendMessageTo(relatedIdentity);
                createdMessages++;
            }

            if (relatedIdentity.HasAvailabilityToSendNewMessages() && relatedIdentity.HasAvailabilityToReceiveNewMessages())
                createdMessages += SendMessagesRecursive(relatedIdentity, i);
        }
        return createdMessages;
    }

    private void CreateInitialNodes()
    {
        // create a single identity for each pool
        foreach (var poolEntry in _pools.Where(p => p.Amount > 0))
        {
            for (uint i = 0; i < poolEntry.Amount; i++)
            {
                poolEntry.Identities.Add(new Identity(
                      new UserCredentials("USR" + PasswordHelper.GeneratePassword(8, 8), PasswordHelper.GeneratePassword(18, 24)),
                      "ID1" + PasswordHelper.GeneratePassword(16, 16),
                      "DVC" + PasswordHelper.GeneratePassword(8, 8),
                      poolEntry,
                      i
                    )
              );
            }
        }
    }
}
