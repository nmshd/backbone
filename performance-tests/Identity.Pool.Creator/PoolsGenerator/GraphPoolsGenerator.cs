using System.Collections;
using Backbone.ConsumerApi.Sdk.Authentication;
using Backbone.Identity.Pool.Creator.Application.Checkers;
using Backbone.Identity.Pool.Creator.Application.Printer;
using Backbone.Identity.Pool.Creator.PoolsFile;
using Backbone.Tooling;

namespace Backbone.Identity.Pool.Creator.GraphPoolsGenerator;

/// <summary>
/// We use a different approach here. Instead of creating all identities, then their relationships and lastly their messages,
/// instead we create a handful of identities first, with no relationships nor messages. This can be considered a graph
/// where relationships are represented by edges, and messages are represented by weighted edges.
/// 
/// After this initial setup, the allocation of messages is done using a mix of relationship creation and pre-existing relationship usage,
/// as per the limits set in the pool configuration.
/// </summary>
public class GraphPoolsGenerator
{
    private readonly string _baseAddress;
    private readonly ClientCredentials _clientCredentials;
    private readonly IPrinter _printer;
    private readonly List<PoolEntry> _pools;

    public GraphPoolsGenerator(
        string baseAddress,
        string clientId,
        string clientSecret,
        PoolFileRoot configuration,
        IPrinter printer)
    {
        _baseAddress = baseAddress;
        _clientCredentials = new ClientCredentials(clientId, clientSecret);
        _printer = printer;
        _pools = configuration.Pools.ToList();
    }

    public async Task CreatePools()
    {
        CreateInitialNodes();

        PoolsOffset.CreateOffsetPools(_pools);

        DeepGenerateV2();

        var (success, messages) = _pools.CheckSolution();
        if (!success)
        {
            Console.WriteLine("Solution validation failed.");

            foreach (var message in messages)
            {
                Console.WriteLine(message);
            }
        }

        _printer.PrintRelationships(_pools, summaryOnly: false);
        _printer.PrintMessages(_pools, summaryOnly: false);
    }

    /// TO BE GENERATED BY COPILOT
    /// <summary>
    /// This is the main engine in the program. This method should look into the _pools object and generate relationships for the identities.
    /// It should also exchange messages between identities of each kind of pool. The method should be able to maximize the number of established relationships and
    /// exchanged messages, meeting at least the expected number of sent messages and established relationships.
    /// Due to the possibility to reach local maxima, the method may implement some form of backtracking to explore other solutions.
    /// 
    /// 
    /// </summary>
    // Assuming the context of the GraphPoolsGenerator class and its fields
    public void DeepGenerateV2()
    {
        // Initialize a structure to keep track of relationships and messages
        var relationships = new Dictionary<(string, string), bool>();
        var messagesExchanged = new Dictionary<(string, string), int>();

        // Method to recursively explore all possibilities
        void Explore(int poolIndex, List<string> currentPath, HashSet<string> visited)
        {
            if (poolIndex >= _pools.Count)
            {
                // Base case: all pools have been explored
                return;
            }

            var currentPool = _pools.ElementAt(poolIndex);
            foreach (var identity in currentPool.Identities.Select(i=>i.Nickname))
            {
                if (visited.Contains(identity)) continue;

                // Mark this identity as visited
                visited.Add(identity);

                // For each identity in the current path, establish relationships and exchange messages
                foreach (var prevIdentity in currentPath)
                {
                    var pair = (prevIdentity, identity);
                    var reversePair = (identity, prevIdentity);

                    // Establish relationship
                    relationships[pair] = true;

                    // Exchange messages
                    if (!messagesExchanged.ContainsKey(pair) && !messagesExchanged.ContainsKey(reversePair))
                    {
                        messagesExchanged[pair] = 1; // Initialize with one message
                    }
                    else
                    {
                        if (messagesExchanged.ContainsKey(pair))
                        {
                            messagesExchanged[pair]++;
                        }
                        else
                        {
                            messagesExchanged[reversePair]++;
                        }
                    }
                }

                // Add current identity to the path and move to the next pool
                currentPath.Add(identity);
                Explore(poolIndex + 1, currentPath, visited);

                // Backtrack: remove the current identity from the path and visited set for the next iteration
                currentPath.RemoveAt(currentPath.Count - 1);
                visited.Remove(identity);
            }
        }

        // Start exploring from the first pool
        Explore(0, new List<string>(), new HashSet<string>());

        // At this point, relationships and messagesExchanged dictionaries are filled with all possible relationships and messages
        // This method can be extended or modified to optimize the relationships and messages based on specific criteria
    }

    private void DeepGenerateV1()
    {
        Console.WriteLine($"Got called with {_pools.NumberOfEstablishedRelationships()} relationships already established and {_pools.NumberOfSentMessages()} messages sent.");

        var enm = _pools.ExpectedNumberOfSentMessages();
        var enr = _pools.ExpectedNumberOfRelationships();

        Console.WriteLine($"Targets are {enr} relationships and {enm} messages sent.");


        while (true)
        {
            var identities = _pools.SelectMany(p => p.Identities).OrderBy(i => i.GraphAlgorithmVisitCount).ToList();

            uint createdSum = 0;
            foreach (var identity in identities)
            {
                createdSum += SendMessagesRecursive(identity);
            }

            createdSum += AddRelationship();

            if (createdSum == 0)
                break;
        }
    }

    private uint AddRelationship()
    {
        var appIdentitiesWithTheHighestRelationshipCapacity = new Queue<Identity>(
            _pools.GetAppPools()
            .SelectMany(p => p.Identities)
            .Where(i => i.HasAvailabilityForNewRelationships())
            .OrderBy(i => i.Pool.NumberOfRelationships));

        var connectorIdentitiesWithTheHighestRelationshipCapacity = new Queue<Identity>(
            _pools.GetConnectorPools()
            .SelectMany(p => p.Identities)
            .Where(i => i.HasAvailabilityForNewRelationships())
            .OrderBy(i => i.Pool.NumberOfRelationships)
            .ToList());

        while (appIdentitiesWithTheHighestRelationshipCapacity.Any() && connectorIdentitiesWithTheHighestRelationshipCapacity.Any())
        {
            var appIdentityWithTheHighestRelationshipCapacity = appIdentitiesWithTheHighestRelationshipCapacity.Dequeue();
            var connectorIdentityWithTheHighestRelationshipCapacity = connectorIdentitiesWithTheHighestRelationshipCapacity.Dequeue();

            if (appIdentityWithTheHighestRelationshipCapacity.AddIdentityToEstablishRelationshipsWith(connectorIdentityWithTheHighestRelationshipCapacity)) return 1u;
        }

        return 0u;
    }

    private uint SendMessagesRecursive(Identity i, Identity? callingIdentity = null)
    {
        i.GraphAlgorithmVisitCount++;
        uint createdMessages = 0;
        var relatedIdentities = i.IdentitiesToEstablishRelationshipsWith.Except([callingIdentity]) as IEnumerable<Identity>;

        foreach (var relatedIdentity in relatedIdentities)
        {
            if (i.HasAvailabilityToSendNewMessages() && relatedIdentity.HasAvailabilityToReceiveNewMessages())
            {
                i.SendMessageTo(relatedIdentity);
                createdMessages++;
            }

            if (relatedIdentity.HasAvailabilityToSendNewMessages() && relatedIdentity.HasAvailabilityToReceiveNewMessages())
                createdMessages += SendMessagesRecursive(relatedIdentity, i);
        }
        return createdMessages;
    }

    private void CreateInitialNodes()
    {
        // create a single identity for each pool
        foreach (var poolEntry in _pools.Where(p => p.Amount > 0))
        {
            for (uint i = 0; i < poolEntry.Amount; i++)
            {
                poolEntry.Identities.Add(new Identity(
                      new UserCredentials("USR" + PasswordHelper.GeneratePassword(8, 8), PasswordHelper.GeneratePassword(18, 24)),
                      "ID1" + PasswordHelper.GeneratePassword(16, 16),
                      "DVC" + PasswordHelper.GeneratePassword(8, 8),
                      poolEntry,
                      i
                    )
              );
            }
        }
    }
}
